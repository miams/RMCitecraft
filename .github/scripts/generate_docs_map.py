#!/usr/bin/env python3
"""
Generate RMCitecraft Documentation Map

This script scans all Markdown files in the project and creates a comprehensive
documentation map with headings, similar to Claude Code's documentation map.
"""

import re
from pathlib import Path
from datetime import datetime, timezone
from typing import List, Dict, Tuple
from dataclasses import dataclass


@dataclass
class Heading:
    """Represents a heading in a markdown file."""
    level: int
    text: str
    line_number: int


@dataclass
class DocumentEntry:
    """Represents a documentation file with its headings."""
    path: Path
    relative_path: str
    title: str
    headings: List[Heading]
    category: str


def extract_headings(file_path: Path) -> List[Heading]:
    """Extract all headings from a markdown file."""
    headings = []

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                # Match markdown headings (# Header)
                match = re.match(r'^(#{1,6})\s+(.+)$', line.strip())
                if match:
                    level = len(match.group(1))
                    text = match.group(2).strip()
                    headings.append(Heading(level, text, line_num))
    except Exception as e:
        print(f"Warning: Could not read {file_path}: {e}")

    return headings


def categorize_document(relative_path: str) -> str:
    """Categorize a document based on its path and name."""
    path_lower = relative_path.lower()

    # Root-level categorization
    if path_lower in ['readme.md', 'quickstart.md', 'quickstart-ui.md']:
        return 'Getting Started'

    if path_lower in ['claude.md', 'prd.md', 'project-plan.md']:
        return 'Project Overview'

    # Directory-based categorization
    if path_lower.startswith('docs/reference/'):
        return 'Database Reference'

    if path_lower.startswith('docs/'):
        return 'Architecture & Design'

    if path_lower.startswith('sqlite-extension/'):
        return 'Database Integration'

    if path_lower.startswith('extension/'):
        return 'Browser Extension'

    # Content-based categorization
    if any(x in path_lower for x in ['week', 'progress', 'summary']):
        return 'Development Progress'

    if any(x in path_lower for x in ['fix', 'optimization', 'support']):
        return 'Implementation Notes'

    return 'Other Documentation'


def get_document_title(doc_path: Path, headings: List[Heading]) -> str:
    """Get the title of a document from its first H1 heading or filename."""
    # Try to find the first H1 heading
    for heading in headings:
        if heading.level == 1:
            return heading.text

    # Fallback to filename without extension
    return doc_path.stem.replace('-', ' ').replace('_', ' ').title()


def scan_documentation(root_dir: Path) -> List[DocumentEntry]:
    """Scan all markdown files in the project."""
    docs = []

    # Find all markdown files
    md_files = sorted(root_dir.glob('**/*.md'))

    for md_file in md_files:
        # Skip files in certain directories
        relative_path = md_file.relative_to(root_dir)
        if any(part.startswith('.') for part in relative_path.parts):
            continue
        if 'node_modules' in relative_path.parts:
            continue
        if '.venv' in relative_path.parts:
            continue

        headings = extract_headings(md_file)
        title = get_document_title(md_file, headings)
        category = categorize_document(str(relative_path))

        docs.append(DocumentEntry(
            path=md_file,
            relative_path=str(relative_path),
            title=title,
            headings=headings,
            category=category
        ))

    return docs


def format_heading_tree(headings: List[Heading]) -> List[str]:
    """Format headings as a nested bullet list."""
    if not headings:
        return []

    lines = []

    # Skip the first H1 (document title) and start from H2
    for heading in headings:
        if heading.level == 1:
            continue  # Skip H1 as it's the document title

        # Calculate indentation (H2 = 0 spaces, H3 = 2 spaces, etc.)
        indent = '  ' * (heading.level - 2)
        lines.append(f"{indent}- {heading.text}")

    return lines


def generate_docs_map(docs: List[DocumentEntry]) -> str:
    """Generate the complete documentation map."""
    lines = [
        "# RMCitecraft Documentation Map",
        "",
        "> **Note**: This file is auto-generated by GitHub Actions. Do not edit manually.",
        f"> Last generated: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}",
        "",
        "This is a comprehensive map of all RMCitecraft documentation with headings, ",
        "designed for easy navigation by LLMs and developers.",
        "",
    ]

    # Group documents by category
    categories: Dict[str, List[DocumentEntry]] = {}
    for doc in docs:
        if doc.category not in categories:
            categories[doc.category] = []
        categories[doc.category].append(doc)

    # Define category order
    category_order = [
        'Getting Started',
        'Project Overview',
        'Architecture & Design',
        'Database Reference',
        'Database Integration',
        'Browser Extension',
        'Implementation Notes',
        'Development Progress',
        'Other Documentation',
    ]

    # Sort categories
    sorted_categories = sorted(
        categories.keys(),
        key=lambda x: category_order.index(x) if x in category_order else 999
    )

    # Generate output for each category
    for category in sorted_categories:
        category_docs = sorted(categories[category], key=lambda x: x.relative_path)

        lines.append(f"## {category}")
        lines.append("")

        for doc in category_docs:
            # Document link
            github_url = f"https://github.com/mikeiacovacci/RMCitecraft/blob/main/{doc.relative_path}"
            lines.append(f"### [{doc.title}]({github_url})")
            lines.append("")

            # Add heading tree
            heading_tree = format_heading_tree(doc.headings)
            if heading_tree:
                lines.extend(heading_tree)
                lines.append("")

        lines.append("")

    return '\n'.join(lines)


def main():
    """Main entry point."""
    # Get repository root (assuming script is in .github/scripts/)
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent.parent

    print(f"Scanning documentation in: {repo_root}")

    # Scan all documentation
    docs = scan_documentation(repo_root)
    print(f"Found {len(docs)} documentation files")

    # Generate the map
    docs_map = generate_docs_map(docs)

    # Write to output file
    output_path = repo_root / 'claude_code_docs_map.md'
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(docs_map)

    print(f"Documentation map generated: {output_path}")


if __name__ == '__main__':
    main()
